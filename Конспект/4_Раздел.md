# 4. МЕТОДЫ ПОИСКА

Конспект для подготовки к экзамену по курсу «Информатика (организация и поиск данных)».

---

## 4.1. Ассоциативная память, словарь. Варианты реализации, сравнение асимптотики

**Словарь (map):** пары (ключ, значение), put и get.

**На хеш-таблице:** O(1) в среднем для вставки и поиска. Не упорядочен.

**На дереве поиска (красно-чёрное):** O(log n) для вставки и поиска. Упорядоченный обход, диапазонные запросы.

| Реализация | Вставка | Поиск по ключу |
|------------|---------|----------------|
| Хеш-таблица | O(1) ср. | O(1) ср. |
| Дерево поиска | O(log n) | O(log n) |

---

## 4.2. Полиморфный АТД «Множество»: реализация на базе хеш-таблиц

Множество — коллекция уникальных элементов. Реализация: хеш-таблица, ключ = элемент. insert O(1) ср., contains O(1) ср.

---

## 4.3. Полиморфный АТД «Множество»: реализация на базе дерева поиска (бинарного или B-дерева)

Реализация: BST или B-дерево. insert O(log n), contains O(log n). Плюс упорядоченный обход.

---

## 4.4. Организация пространства состояний в виде n-арного дерева: основные идеи (на примере задачи о рюкзаке)

**Рюкзак 0/1:** n предметов, вес w[i], ценность v[i], вместимость W. Дерево решений: вершина — состояние (i, weight); два ребёнка — «взять предмет i» и «не взять». 2^n листьев. Рекурсия: `max(knapsack(i+1, w), v[i] + knapsack(i+1, w+w[i]))` с отсечением при w+w[i] > W.

---

## 4.5. Организация пространства состояний в виде n-арного дерева: основные идеи (на примере минимаксного алгоритма)

**Минимакс:** вершины — позиции в игре, рёбра — ходы. Max выбирает max по детям, Min — min. Оценка листа — результат игры или эвристика. **Альфа-бета отсечение:** если ветвь даёт оценку, при которой родитель не выберет этот узел, остальные ветви не просматриваем.

---

## 4.6. Ускорение поиска с помощью кеширования

**Мемоизация** — кеш результатов по аргументам. При повторном вызове — возврат из кеша. Превращает экспоненциальную рекурсию в полиномиальную. **Динамическое программирование** — восходящая мемоизация (таблица).

---

## 4.7. Ускорение поиска с помощью индексирования

**Индекс** — вспомогательная структура для быстрого поиска. **B+-дерево** в БД — O(log n) поиск, диапазоны. **Обратный индекс** — слово → список документов.

---

## 4.8. Сравнительная характеристика систем: реального времени, онлайн, асинхронных

| Тип | Описание |
|-----|----------|
| Real-time | Гарантированный отклик в заданные сроки (управление, embedded). |
| Online | Данные потоком, решение без полного входа (стриминг). |
| Асинхронные | Вызов не блокирует; результат через callback, future. |

---

## 4.9. Разреженные структуры: одномерные

Большинство элементов — нули. **На дереве поиска:** индекс → значение, O(log k). **На словаре (хеш):** O(1) ср. k — число ненулевых.

---

## 4.10. Разреженные структуры: многомерные

**На ассоциативной памяти:** ключ (i, j) или (i1, i2, …) → значение. O(log k) или O(1) ср.

---

## 4.11. Пространственные данные: одномерный случай. Дерево отрезков

Запросы на отрезке [l, r] (сумма, min, max) и точечные обновления за O(log n). Полное бинарное дерево: листья — элементы, узел — агрегат по отрезку детей. Запрос — разбиение [l, r] на O(log n) отрезков узлов; обновление — спуск до листа, пересчёт вверх.

```cpp
int query(int v, int tl, int tr, int l, int r) {
    if (l > tr || r < tl) return 0;
    if (l <= tl && tr <= r) return tree[v];
    int tm = (tl + tr) / 2;
    return query(2*v, tl, tm, l, r) + query(2*v+1, tm+1, tr, l, r);
}
```
