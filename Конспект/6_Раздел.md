# 6. ИДИОМЫ И ПРИЁМЫ ООП (C++)

Конспект для подготовки к экзамену по курсу «Информатика (организация и поиск данных)».

---

## 6.1. Указатель как идиома и варианты реализации через индексирование коллекций и с помощью итераторов

**Указатель** — адрес в памяти. Инвалидируется при realloc. **Индекс** — позиция в контейнере, остаётся корректным при перемещении. **Итератор** — абстракция позиции, `++`, `*`, `!=`.

---

## 6.2. Арифметика указателей в C/C++

`p + k` — сдвиг на k элементов. `p - q` — разность в элементах. `*(p+5) == p[5]`. Random Access: `it+k`; Bidirectional: `++`, `--`.

---

## 6.3. Переопределение операторов в C++

Функция-член (левый операнд — this) или свободная (для симметрии, например `k * v`). Не изменять операнды для `+`; `operator=` — член класса.

---

## 6.4. Особенности переопределения операторов new и delete

`new T` → operator new (выделение) → конструктор. `delete p` → деструктор → operator delete. Перегрузка для пулов, отладки. Можно перегрузить глобально или для класса.

---

## 6.5. Умные указатели

**unique_ptr** — единоличное владение, RAII. **shared_ptr** — подсчёт ссылок. **weak_ptr** — разрыв циклов, не увеличивает счётчик.

---

## 6.6. Out-параметры в функциях и методах

Передача по ссылке/указателю для возврата результата. Альтернативы: optional, pair, структура по значению.

---

## 6.7. Шаблоны и параметрический полиморфизм. Связь с подтипизацией

**Шаблоны** — параметрический полиморфизм, статический (компиляция). **Подтипизация** — наследование, виртуальные функции, динамическая диспетчеризация. Оба механизма дополняют друг друга.

---

## 6.8. Наследование, ad hoc-полиморфизм и правила переопределения методов и их перегрузок

**Перегрузка** — один итог, разные параметры, выбор на этапе компиляции. **Override** — переопределение виртуального метода, выбор во время выполнения. Ключевое слово `override` — проверка сигнатуры.

---

## 6.9. Изменяемые и неизменяемые структуры: сравнительная характеристика

**Mutable** — операции изменяют объект. **Immutable** — возвращают новый. Immutable проще для параллелизма.

---

## 6.10. Объекты как глобальные константы: ленивая реализация с помощью мемоизации

Статическая локальная переменная — инициализация при первом обращении, результат кешируется. В C++11 потокобезопасна.

---

## 6.11. Контроль и управление памятью

**Копирование** — конструктор копирования, оператор присваивания. **Перемещение** — `T&&`, `std::move`. **lvalue** — имеет адрес, **rvalue** — временное. **Виртуальный деструктор** — обязателен при полиморфном delete. **Порядок:** базы → члены → тело конструктора; уничтожение в обратном порядке.

---

## 6.12. Абстрагирование зависимостей и разделение ответственностей (на примере Sequence)

Зависимость от интерфейса, а не от реализации. **Пример Sequence:**
```cpp
struct ISequence {
    virtual bool hasNext() = 0;
    virtual int next() = 0;
    virtual ~ISequence() = default;
};
void process(ISequence& seq) {
    while (seq.hasNext()) use(seq.next());
}
```
Конкретная реализация (ArraySequence, FileSequence) передаётся снаружи. Код process не знает источник данных.

---

## 6.13. Инкапсуляция и изоляция. Связь с friend-классами

**Инкапсуляция** — сокрытие реализации. **friend** даёт доступ к private. Используется для операторов, тестов. Ослабляет инкапсуляцию.

---

## 6.14. Понятие объектной модели. Пример

**Объектная модель** — правила размещения объектов в памяти. Члены последовательно, выравнивание. Виртуальные функции → vtable, указатель в объекте. **Пример:** класс с полями a, b и виртуальным foo: в памяти сначала vptr, затем a, b. Вызов foo — через vptr[vtable_index].

---

## 6.15. Понятие атрибута объекта. Реализация концепции атрибута средствами ООП

**Атрибут** — именованное свойство с типом. Реализация: поле + геттер + сеттер.

---

## 6.16. Подтипизация и наследование. Изменение внешней спецификации при подтипизации

**LSP:** подтип заменяем на базовый. Нельзя сужать предусловия, ослаблять постусловия. При наследовании можно только расширять гарантии.

---

## 6.17. Подтипизация и наследование. Проблемы множественного наследования. Ромбовидное наследование

**Множественное наследование** — несколько базовых подобъектов. Неоднозначность при общем члене. **Ромбовидное:** A←B, A←C, B,C←D. Без virtual — два подобъекта A в D. **Виртуальное наследование** — один подобъект A. Конструктор A вызывается из D.
