# 5. ГРАФОВЫЕ АЛГОРИТМЫ

Конспект для подготовки к экзамену по курсу «Информатика (организация и поиск данных)».

---

## 5.1. Структуры данных для представления ориентированного графа с взвешенными дугами

**Список смежности:** для каждой вершины — список пар (куда, вес). Дуга u→v в списке u. O(V+E) память.

**Матрица смежности:** adj[i][j] = вес дуги i→j. O(V²) память, O(1) проверка ребра.

---

## 5.2. Структуры данных для представления неориентированного графа с взвешенными рёбрами

Ребро (u,v) храним дважды: в списке u и в списке v. Матрица смежности — симметричная.

---

## 5.3. Способы реализации матрицы смежности. Обзор и сравнительная характеристика

**Плотная:** массив V×V. O(1) доступ, O(V²) память. **Разреженная:** map (i,j)→weight или список списков. Экономия при E << V².

---

## 5.4. Обход ориентированного графа в ширину (алгоритм)

Очередь, массив visited. Кладём start. Пока очередь не пуста: достаём u, для каждого непосещённого соседа v помечаем visited и кладём v. O(V+E). Находит кратчайшие пути в невзвешенном графе.

---

## 5.5. Обход ориентированного графа в глубину (алгоритм)

Рекурсия или стек. Помечаем u, для каждого непосещённого соседа v вызываем DFS(v). O(V+E). Применения: топологическая сортировка (DAG), поиск циклов.

---

## 5.6. Обход неориентированного графа в ширину (алгоритм)

Тот же алгоритм, что и для ориентированного. Очередь, visited. O(V+E).

---

## 5.7. Обход неориентированного графа в глубину (алгоритм)

Тот же алгоритм. Стек или рекурсия. O(V+E). Применения: компоненты связности, поиск циклов.

---

## 5.8. Полиморфный АТД «Очередь с приоритетами»: реализация на основе бинарной кучи

**Операции:** insert O(log n), extractMin O(log n), peek O(1). Храним пары (приоритет, элемент) в min-heap. Сверху — минимум.

---

## 5.9. Полиморфный АТД «Очередь с приоритетами»: реализация на основе связанного списка

**Отсортированный список:** insert — поиск позиции O(n), extractMin — удаление головы O(1). **Несортированный:** insert O(1), extractMin O(n).

---

## 5.10. Поиск кратчайших путей: алгоритм Дейкстры

Кратчайшие пути из одной вершины. Веса неотрицательные. На каждом шаге фиксируем вершину с минимальным dist, релаксируем рёбра. Очередь с приоритетами по dist. O((V+E) log V). Пропускать устаревшие записи в очереди.

---

## 5.11. Динамическое программирование: нисходящий процесс

Рекурсия + мемоизация. Заполняем кеш при обращении. Пример: Fibonacci с memo[n].

---

## 5.12. Динамическое программирование: восходящий процесс

Таблица от базовых случаев к целевым. Без рекурсии. Пример: dp[i] = dp[i-1] + dp[i-2].

---

## 5.13. Раскраска графа. Алгоритм Ершова (DSatur)

Присвоить вершинам цвета так, что соседи разного цвета. **DSatur:** на каждом шаге выбираем вершину с максимальной степенью насыщения (число цветов у соседей); при равенстве — максимальной степенью. Красим в минимальный допустимый цвет.

---

## 5.14. Поиск остова графа. Алгоритм Прима

Растущее дерево. На каждом шаге добавляем минимальное ребро из MST во внешнюю вершину. Куча по весу рёбер. O(E log V).

---

## 5.15. Поиск остова графа. Алгоритм Краскала

Рёбра по возрастанию веса. Добавляем, если не создаёт цикл. Union-Find для проверки компонент. find со сжатием пути, unite по рангу. O(E log E).
