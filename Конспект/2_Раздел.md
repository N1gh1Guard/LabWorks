# 2. АЛГОРИТМЫ СОРТИРОВКИ

Конспект для подготовки к экзамену по курсу «Информатика (организация и поиск данных)».

---

## 2.1. Алгоритмы сортировки: классификация

**Устойчивость** — равные сохраняют порядок. **In-place** — O(1) доп. памяти. **Принципы:** обменные, выбором, вставками, слиянием, распределительные.

| Алгоритм | Устойчивость | In-place | Принцип | Худший |
|----------|--------------|----------|---------|--------|
| Bubble | Да | Да | Обменный | O(n²) |
| Quick | Нет | Да | Обменный | O(n²) |
| Selection | Нет | Да | Выбором | O(n²) |
| Heap | Нет | Да | Выбором | O(n log n) |
| Insertion | Да | Да | Вставками | O(n²) |
| Shell | Нет | Да | Вставками | O(n^1.3) |
| Merge | Да | Нет | Слиянием | O(n log n) |

---

## 2.2. Обменные сортировки: общий принцип, примеры, асимптотическая оценка сложности

**Принцип:** сравнение и обмен пар элементов.

**Пример — пузырьковая:**
```cpp
for (size_t i = 0; i < n; ++i)
    for (size_t j = 0; j < n - 1 - i; ++j)
        if (a[j] > a[j+1]) std::swap(a[j], a[j+1]);
```
O(n²), устойчива.

**Пример — Quick Sort, partition:**
```cpp
int partition(int* a, int lo, int hi) {
    int pivot = a[(lo+hi)/2], i = lo-1, j = hi+1;
    while (true) {
        do ++i; while (a[i] < pivot);
        do --j; while (a[j] > pivot);
        if (i >= j) return j;
        std::swap(a[i], a[j]);
    }
}
```
Partition O(n). Рекурсия: QuickSort(lo, p), QuickSort(p+1, hi). Средний O(n log n), худший O(n²). Неустойчива.

---

## 2.3. Сортировки выбором: общий принцип, примеры, асимптотическая оценка сложности

**Принцип:** на каждом шаге выбрать экстремум среди неотсортированных и поставить на место.

**Пример — сортировка выбором:**
```cpp
for (size_t i = 0; i < n; ++i) {
    size_t minIdx = i;
    for (size_t j = i+1; j < n; ++j)
        if (a[j] < a[minIdx]) minIdx = j;
    std::swap(a[i], a[minIdx]);
}
```
O(n²), неустойчива.

**Heap Sort:** heapify O(n), затем n раз extractMax O(log n). Итого O(n log n).

---

## 2.4. Сортировки вставкой: общий принцип, примеры, асимптотическая оценка сложности

**Принцип:** вставка следующего элемента в отсортированную часть.

**Пример — сортировка вставками:**
```cpp
for (size_t i = 1; i < n; ++i) {
    int x = a[i]; size_t j = i;
    while (j > 0 && a[j-1] > x) { a[j] = a[j-1]; --j; }
    a[j] = x;
}
```
O(n²), на почти отсортированных O(n), устойчива.

**Shell:** вставки с шагом gap (n/2, n/4, …). O(n^1.3), неустойчива.

---

## 2.5. Декомпозиция задач на примере алгоритма быстрой сортировки

**Декомпозиция** — разбиение на подзадачи того же типа.

1. **Базовый случай:** размер 0–1 — отсортирован.
2. **Разделение:** partition за O(n) — элементы < pivot слева, ≥ справа.
3. **Рекурсия:** QuickSort левой и правой части.

При разбиении пополам — глубина O(log n), работа по уровням O(n) → O(n log n). При худшем разбиении — O(n²). Улучшения: median-of-three, случайный pivot, insertion sort для малых подмассивов.
