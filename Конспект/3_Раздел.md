# 3. ЛЕНИВЫЕ ВЫЧИСЛЕНИЯ

Конспект для подготовки к экзамену по курсу «Информатика (организация и поиск данных)».

---

## 3.1. Концепция ленивой последовательности. Логическое определение и внешняя спецификация

**Логическое определение:** последовательность — Nil или Cons(head, tail), где tail вычисляется лениво. Рекурсивная структура.

**Внешняя спецификация:** head(), tail(), isEmpty(), hasNext(). Элементы вычисляются при обращении, не при создании.

---

## 3.2. Концепция ленивой последовательности. Основные приемы реализации

**Замыкание-генератор:** функция при вызове возвращает (head, tail) или «конец». **Мемоизация** — кеш результата генератора. Пример на псевдокоде: `naturals(n)` возвращает `Cons(n, lazy(naturals(n+1)))`.

---

## 3.3. Понятие ординального числа. Использование ординалов для индексирования последовательностей

**Ординал** — позиция: 0, 1, 2, … или past-the-end. Доступ по ординалу k: k раз tail, затем head. Связь с итератором end в C++.

---

## 3.4. Арифметика ленивых последовательностей. Конкатенация, вставка. Удаление подпоследовательности

**Конкатенация:** после первой идут элементы второй; генератор: head первой, tail = concat(tail первой, вторая). **Вставка:** обход до позиции k, вставка элемента, конкатенация с хвостом. **Удаление [k, k+m]:** обход до k, пропуск m элементов, конкатенация «до» и «после».

---

## 3.5. «Двунаправленная» ленивая последовательность. Приемы реализации

Буфер пройденных элементов. Движение вперёд — read из генератора, добавление в буфер. Движение назад — read из буфера. Альтернатива — кольцевой буфер.

---

## 3.6. Поток данных (stream). Назначение и принцип реализации

**Назначение:** абстракция последовательного доступа к данным из разных источников. **Принцип:** единый интерфейс hasNext/eof, read; конкретная реализация — для массива, файла, сети.

---

## 3.7. Поток данных. Пример реализации потока, считывающего данные из бинарного файла

```cpp
class FileByteStream {
    FILE* f_;
    uint8_t buf_[4096];
    size_t bufPos_, bufLen_;
    bool fillBuf() {
        bufLen_ = fread(buf_, 1, sizeof(buf_), f_);
        bufPos_ = 0;
        return bufLen_ > 0;
    }
public:
    bool hasNext() { return bufPos_ < bufLen_ || !feof(f_); }
    uint8_t read() {
        if (bufPos_ >= bufLen_) fillBuf();
        return buf_[bufPos_++];
    }
};
```
Буферизация уменьшает обращения к диску.

---

## 3.8. Поток данных. Пример реализации потока, считывающего данные из массива

```cpp
template<typename T>
class ArrayStream {
    const T* data_;
    size_t size_, pos_;
public:
    ArrayStream(const T* arr, size_t n) : data_(arr), size_(n), pos_(0) {}
    bool hasNext() const { return pos_ < size_; }
    T read() { return data_[pos_++]; }
};
```

---

## 3.9. Кодирование потока данных, пример алгоритма

**RLE (Run-Length Encoding):** серии одинаковых символов → (символ, длина).

Кодирование:
```cpp
char prev = read(); int count = 1;
while (hasNext()) {
    char c = read();
    if (c == prev) ++count;
    else { write(prev, count); prev = c; count = 1; }
}
write(prev, count);
```

Декодирование: для каждой пары (c, n) выводим c n раз.
